---
layout: post
title: "using WHERE method rather than Where-Object"
description: "Getting extra functionality from a .Net method."
category: articles
tags: [sample post, readability, test]
---

Perhaps one of the most common PowerShell commandlets is [Where-Object](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/where-object) which lets you filter items in the pipeline, preventing unwanted items from the left operator being passed to the right operator. There are many commadlets that have a similar (in name and functionality) .Net method and in our case this is the [.where](https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.where) method. Now the sacrifice we have to make when using .Net methods in PowerShell is that they dont play all that well with the PowerShell pipeline so you need to weigh the benefits of each and decide thoughtfully which to use. Here I will make a case for using the .Net Where method for a specific functionality.

First, some background understanding we will take a look at strings and delimiters and assignment of values.

Let's create a list of pets

````powershell
$Pets = "cat, dog, parrot, budgie"
# this is all one string
$Pets
````

![A list of pets](/images/post_images/img210315_01.jpg)

Now, we can split the string using the -split operator and then we are given output that is similar to an array. This means we can get specific values from the array by specifying the element index (zero-based) number that we are interested in.

````powershell
# we can split on a given character - note in the output the character gets consumed in the splitting
$pets -split ','

# this output is an array so we can ask for specific elements by their ID
($pets -split ',')[1] # specify a single ID
($pets -split ',')[0..2] # specify a range of element IDs
($pets -split ',')[1, 2] # specify individual element IDs
````

This last option where we specify two or more elements is interesting. We can actually use that in a variable assignment line like this.

```powershell
$Pet1, $Pet2 = ($pets -split ',')[1, 2]

$Pet1
$Pet2
```

![results of script](/images/post_images/img210317_02.png)

OK then, that's pretty neat, assigning two variables with values from a result that gives two values. You can do this with more but that is perhaps the topic of another blog one day.

Keep this process in mind while we take a look at the .Net string method where.

````powershell
# putting that to one side, let's take a look at .Where method
# Lets create an array to work with
$PetsArray = ($pets -split ',')
# filtering with the PowerShell native where-object commandlet
$PetsArray | where-object {$_ -like "*a*"}

# similar filter with the .Net where method
$PetsArray.Where({$_ -like "*a*"})
````

Well, the output is the same, the syntax isn't very different, just what differences are there? One down-side, as already mentioned, the .Net method doesnt work in a PowerShell pipeline but on the positive side, it is often faster when dealing with big arrays. I tested this a little and it is approx 50% faster on a test array of 1M items. Of course test this yourself, my testing might not represent your use case.

but what you dont often encounter are the extras ... 

### What extras?!

````powershell
# we can go and look at online references or run this line to see the options in the error message!
$PetsArray.Where()
# "Cannot find an overload for ".Where({ expression } [, mode [, numberToReturn]])" "
````
### What does that tell us? 

**{expression}** shown inside curly braces is a mandatory paramter. That makes sense this is the fundamental logic of the where operator that we want to have filtering our data.

**[mode]** a parameter in square brackets means it is optional

**[numbertoreturn]** square brackets so also optional

Now we know **{expression}** - That is what we have used and we can safely assume that **numbertoreturn** is an integer. So we need to find the acceptable values for **mode** and to do that we can get the command line to show us by typing ```[System.Management.Automation.WhereOperatorSelectionMode]::``` and then pressing Ctrl+Space
````powershell
# we have to explore the WhereOperatorSelectionMode enumerator
[System.Management.Automation.WhereOperatorSelectionMode]::  
````
![image](https://user-images.githubusercontent.com/2597535/112724968-ba6d3c80-8f0d-11eb-8b4e-de3183b605e7.png)

From the above screen capture we can see a variety values that we can investigate:
- First
- Last
- SkipUntil
- Split
- Until

|Example|Description|Output|
|---|---|---|
|```$PetsArray.where({$_ -like "*a*"})```|The default use-case that filters items based on the filter specification|Cat, Parrot|
|```$PetsArray.where({$_ -like "*a*"}, 'First')```|Returns the first item encountered by the filter specification|Cat|
|```$PetsArray.where({$_ -like "*a*"}, 'Last')```|Returns the first item encountered by the filter specification|Parrot|
|```$PetsArray.where({$_ -like "*a*"}, 'SkipUntil')```|The default use-case that filters items based on the filter specification||
|```$PetsArray.where({$_ -like "*a*"}, 'Split')```|The default use-case that filters items based on the filter specification||
|```$PetsArray.where({$_ -like "*a*"}, 'Until)```|The default use-case that filters items based on the filter specification||

#default
$MatchedValues = $PetsArray.where({$_ -lt 10})
$MatchedValues

# the .net methods dont provide output to the pipeline - this is a fundamental difference for .foreach, .where, etc

# but they dont have to dispose of the objects that dont match the where filter
$MatchedValues, $NotMatchedValues = $data.where({$_ -eq 10},'split')
$MatchedValues
$NotMatchedValues
````

````powershell
$data = (1..20 )
$data.where({$_ -eq 10},'until')
$result, $otherpart = $data.where({$_ -eq 10},'skipuntil')
$result
$otherpart
````

````powershell
$num = 0
while( $data.count -gt 0){
Write-Verbose "$($data.count) data rows"
$num++
$current, $data = $data.where({$_},"split", 10)
Write-Verbose "$($data.count) data rows : $($count.count) count rows"
$current | add-content "C:\temp\file$num.txt" -Force
}



$Services = (Get-Service)

$Services = (Get-Service).where({$_.status -eq "Running"})


$Services = (Get-Service).where({$_.status -eq "Running"},'split')
````

So there we have it, you can split strings with the .where method and it's pretty fast too. Hope you find an appropriate use for it.

.
