---
layout: post
title: "using WHERE method rather than Where-Object"
description: "Getting extra functionality from a .Net method."
category: articles
tags: [sample post, readability, test]
---

Perhaps one of the most common PowerShell commandlets is [Where-Object](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/where-object) which lets you filter items in the pipeline, preventing unwanted items from the left operator being passed to the right operator. There are many commadlets that have a similar (in name and functionality) .Net method and in our case this is the [.where](https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.where) method. Now the sacrifice we have to make when using .Net methods in PowerShell is that they dont play all that well with the PowerShell pipeline so you need to weigh the benefits of each and decide thoughtfully which to use. Here I will make a case for using the .Net Where method for a specific functionality.

First, some background understanding we will take a look at strings and delimiters and assignment of values.

Let's create a list of pets

````powershell
$Pets = "cat, dog, parrot, budgie"
# this is all one string
$Pets
````

![A list of pets](/images/post_images/img210315_01.jpg)

Now, we can split the string using the -split operator and then we are given output that is similar to an array. This means we can get specific values from the array by specifying the element index (zero-based) number that we are interested in.

````powershell
# we can split on a given character - note in the output the character gets consumed in the splitting
$pets -split ','

# this output is an array so we can ask for specific elements by their ID
($pets -split ',')[1]
($pets -split ',')[0..2]
($pets -split ',')[1, 2]
````

This last option where we specify two or more elements is interesting. We can actually use that in a variable assignment line like this.

```powershell
$Pet1, $Pet2 = ($pets -split ',')[1, 2]

$Pet1
$Pet2
```

![results of script](/images/img210317_02.jpg)

OK then, that's pretty neat, assigning two variables with values from a result that gives two values. You can do this with more but that is perhaps the topic of another blog one day.

Keep this process in mind while we take a look at the .Net string method where.

````powershell
# putting that to one side, let's take a look at .Where method
# Lets create an array to work with
$PetsArray = ($pets -split ',')
# filtering with the where-object
$PetsArray | where-object {$_ -like "*a*"}

# similar filter with the where method
$PetsArray.Where({$_ -like "*a*"})

# advantage ? speed - the .net method is ~50% faster when processing 1M rows

# but what you dont often encounter are the extras ... What extras?!
$PetsArray.Where
# "Cannot find an overload for ".Where({ expression } [, mode [, numberToReturn]])" "
# {expression}
# [mode] - optional
# [numbertoreturn] - optional

# so we know {expression} - we have used that
# we can assume that numbertoreturn is an integer
# how do we find the mode values?
$data|gm -MemberType Method
````

Some content between paragraphs of code

````powershell
# we have to explore the class
[where]

#default
$MatchedValues = $data.where({$_ -lt 10})
$MatchedValues

# the .net methods dont provide output to the pipeline - this is a fundamental difference for .foreach, .where, etc

# but they dont have to dispose of the objects that dont match the where filter
$MatchedValues, $NotMatchedValues = $data.where({$_ -eq 10},'split')
$MatchedValues
$NotMatchedValues
````

````powershell
$data = (1..20 )
$data.where({$_ -eq 10},'until')
$result, $otherpart = $data.where({$_ -eq 10},'skipuntil')
$result
$otherpart
````

````powershell
$num = 0
while( $data.count -gt 0){
Write-Verbose "$($data.count) data rows"
$num++
$current, $data = $data.where({$_},"split", 10)
Write-Verbose "$($data.count) data rows : $($count.count) count rows"
$current | add-content "C:\temp\file$num.txt" -Force
}



$Services = (Get-Service)

$Services = (Get-Service).where({$_.status -eq "Running"})


$Services = (Get-Service).where({$_.status -eq "Running"},'split')
````

So there we have it, you can split strings with the .where method and it's pretty fast too. Hope you find an appropriate use for it.

.
